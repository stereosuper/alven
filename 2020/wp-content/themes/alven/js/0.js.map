{"version":3,"sources":["webpack:///./node_modules/fastdom/src/fastdom-strict.js","webpack:///./node_modules/strictdom/strictdom.js"],"names":[],"mappings":";;;;;;;;;;AAAa;;AAEb,gBAAgB,mBAAO,CAAC,wDAAW;AACnC,cAAc,mBAAO,CAAC,qDAAY;;AAElC;AACA;AACA;AACA,YAAY;AACZ;AACA,gBAAgB,SAA6C;;AAE7D;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;;;;;;;;;;;;AClDA;AACA;;AAEA,gBAAgB,SAAwC;;AAExD;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,oBAAoB,UAAU;AAC9B,oBAAoB,OAAO;AAC3B,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,UAAU;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,UAAU;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc,OAAO;AACrB,cAAc,qBAAqB;AACnC,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,OAAO;AAClB,WAAW,qBAAqB;AAChC,WAAW,UAAU;AACrB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc;AACd;AACA;AACA;;AAEA,gCAAgC;AAChC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,UAAU;AACxB,cAAc,KAAK;AACnB;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc;AACd;AACA;AACA;;AAEA,gCAAgC;AAChC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,UAAU;AACxB,cAAc,KAAK;AACnB;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc;AACd;AACA;AACA;;AAEA,gCAAgC;AAChC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,OAAO;AACrB,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,GAAG;;AAEH;AACA,CAAC;;AAED;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gCAAgC;AAChC,4BAA4B,yCAAyC;AACrE;AACA;AACA,CAAC;;AAED;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gCAAgC;AAChC,4BAA4B,6CAA6C;AACzE;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,CAAC;;AAED;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,mCAAmC,EAAE;;AAEzD;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,mFAAmF;;AAEnF;AACA,KAAK,UAAa,aAAa,mCAAO,YAAY,gBAAgB,EAAE;AAAA,oGAAC;AACrE;;AAEA,CAAC","file":"0.js","sourcesContent":["'use strict';\n\nvar strictdom = require('strictdom');\nvar fastdom = require('../fastdom');\n\n/**\n * Mini logger\n *\n * @return {Function}\n */\nvar debug = 0 ? console.log.bind(console, '[fastdom-strict]') : function() {};\n\n/**\n * Enabled state\n *\n * @type {Boolean}\n */\nvar enabled = false;\n\nwindow.fastdom = module.exports = fastdom.extend({\n  measure: function(fn, ctx) {\n    debug('measure');\n    var task = !ctx ? fn : fn.bind(ctx);\n    return this.fastdom.measure(function() {\n      if (!enabled) return task();\n      return strictdom.phase('measure', task);\n    }, ctx);\n  },\n\n  mutate: function(fn, ctx) {\n    debug('mutate');\n    var task = !ctx ? fn : fn.bind(ctx);\n    return this.fastdom.mutate(function() {\n      if (!enabled) return task();\n      return strictdom.phase('mutate', task);\n    }, ctx);\n  },\n\n  strict: function(value) {\n    if (value) {\n      enabled = true;\n      strictdom.enable();\n    } else {\n      enabled = false;\n      strictdom.disable();\n    }\n  }\n});\n\n// turn on strict-mode\nwindow.fastdom.strict(true);\n","!(function() {\n'use strict';\n\nvar debug = 0 ? console.log.bind(console, '[strictdom]') : function() {};\n\n/**\n * Crude webkit test.\n *\n * @type {Boolean}\n */\n// var isWebkit = !!window.webkitURL;\n\n/**\n * List of properties observed.\n *\n * @type {Object}\n */\nvar properties = {\n  prototype: {\n    Document: {\n      execCommand: Mutate,\n      elementFromPoint: Measure,\n      elementsFromPoint: Measure,\n      scrollingElement: Measure\n    },\n\n    Node: {\n      appendChild: {\n        type: Mutate,\n        test: function(dom, parent, args) {\n          var attached = isAttached(parent) || isAttached(args[0]);\n          if (attached && dom.not('mutate')) throw error(3, this.name);\n        }\n      },\n\n      insertBefore: {\n        type: Mutate,\n        test: function(dom, parent, args) {\n          var attached = isAttached(parent) || isAttached(args[0]);\n          if (attached && dom.not('mutate')) throw error(3, this.name);\n        }\n      },\n\n      removeChild: {\n        type: Mutate,\n        test: function(dom, parent, args) {\n          var attached = isAttached(parent) || isAttached(args[0]);\n          if (attached && dom.not('mutate')) throw error(3, this.name);\n        }\n      },\n\n      textContent: Mutate\n    },\n\n    Element: {\n      scrollIntoView: Mutate,\n      scrollBy: Mutate,\n      scrollTo: Mutate,\n      getClientRects: Measure,\n      getBoundingClientRect: Measure,\n      clientLeft: Measure,\n      clientWidth: Measure,\n      clientHeight: Measure,\n      scrollLeft: Accessor,\n      scrollTop: Accessor,\n      scrollWidth: Measure,\n      scrollHeight: Measure,\n      innerHTML: Mutate,\n      outerHTML: Mutate,\n      insertAdjacentHTML: Mutate,\n      remove: Mutate,\n      setAttribute: Mutate,\n      removeAttribute: Mutate,\n      className: Mutate,\n      classList: ClassList\n    },\n\n    HTMLElement: {\n      offsetLeft: Measure,\n      offsetTop: Measure,\n      offsetWidth: Measure,\n      offsetHeight: Measure,\n      offsetParent: Measure,\n      innerText: Accessor,\n      outerText: Accessor,\n      focus: Measure,\n      blur: Measure,\n      style: Style,\n\n      // `element.dataset` is hard to wrap.\n      // We could use `Proxy` but it's not\n      // supported in Chrome yet. Not too\n      // concerned as `data-` attributes are\n      // not often associated with render.\n      // dataset: DATASET\n    },\n\n    CharacterData: {\n      remove: Mutate,\n      data: Mutate\n    },\n\n    Range: {\n      getClientRects: Measure,\n      getBoundingClientRect: Measure\n    },\n\n    MouseEvent: {\n      layerX: Measure,\n      layerY: Measure,\n      offsetX: Measure,\n      offsetY: Measure\n    },\n\n    HTMLButtonElement: {\n      reportValidity: Measure\n    },\n\n    HTMLDialogElement: {\n      showModal: Mutate\n    },\n\n    HTMLFieldSetElement: {\n      reportValidity: Measure\n    },\n\n    HTMLImageElement: {\n      width: Accessor,\n      height: Accessor,\n      x: Measure,\n      y: Measure\n    },\n\n    HTMLInputElement: {\n      reportValidity: Measure\n    },\n\n    HTMLKeygenElement: {\n      reportValidity: Measure\n    },\n\n    SVGSVGElement: {\n      currentScale: Accessor\n    }\n  },\n\n  instance: {\n    window: {\n      getComputedStyle: {\n        type: Measure,\n\n        /**\n         * Throws when the Element is in attached\n         * and strictdom is not in the 'measure' phase.\n         *\n         * @param  {StrictDom} strictdom\n         * @param  {Window} win\n         * @param  {Object} args\n         */\n        test: function(strictdom, win, args) {\n          if (isAttached(args[0]) && strictdom.not('measure')) {\n            throw error(2, 'getComputedStyle');\n          }\n        }\n      },\n\n      // innerWidth: {\n      //   type: isWebkit ? Value : Measure,\n      //\n      //   /**\n      //    * Throws when the window is nested (in <iframe>)\n      //    * and StrictDom is not in the 'measure' phase.\n      //    *\n      //    * @param  {StrictDom} strictdom\n      //    */\n      //   test: function(strictdom) {\n      //     var inIframe = window !== window.top;\n      //     if (inIframe && strictdom.not('measure')) {\n      //       throw error(2, '`.innerWidth` (in iframe)');\n      //     }\n      //   }\n      // },\n      //\n      // innerHeight: {\n      //   type: isWebkit ? Value : Measure,\n      //\n      //   /**\n      //    * Throws when the window is nested (in <iframe>)\n      //    * and StrictDom is not in the 'measure' phase.\n      //    *\n      //    * @param  {StrictDom} strictdom\n      //    */\n      //   test: function(strictdom) {\n      //     var inIframe = window !== window.top;\n      //     if (inIframe && strictdom.not('measure')) {\n      //       throw error(2, '`.innerHeight` (in iframe)');\n      //     }\n      //   }\n      // },\n      //\n      // scrollX: isWebkit ? Value : Measure,\n      // scrollY: isWebkit ? Value : Measure,\n      scrollBy: Mutate,\n      scrollTo: Mutate,\n      scroll: Mutate,\n    }\n  }\n};\n\n/**\n * The master controller for all properties.\n *\n * @param {Window} win\n */\nfunction StrictDom(win) {\n  this.properties = [];\n  this._phase = null;\n  this.win = win;\n\n  this.createPrototypeProperties();\n  this.createInstanceProperties();\n}\n\nStrictDom.prototype = {\n\n  /**\n   * Set the current phase.\n   * @param  {[type]} value [description]\n   * @return {[type]}       [description]\n   */\n  phase: function(type, task) {\n    if (!arguments.length) return this._phase;\n    if (!this.knownPhase(type)) throw error(4, type);\n\n    var previous = this._phase;\n    this._phase = type;\n\n    if (typeof task != 'function') return;\n\n    var result = task();\n    this._phase = previous;\n    return result;\n  },\n\n  knownPhase: function(value) {\n    return !!~['measure', 'mutate', null].indexOf(value);\n  },\n\n  is: function(value) {\n    return this._phase === value;\n  },\n\n  not: function(value) {\n    return !this.is(value);\n  },\n\n  /**\n   * Enable strict mode.\n   *\n   * @public\n   */\n  enable: function() {\n    if (this.enabled) return;\n    debug('enable');\n    var i = this.properties.length;\n    while (i--) this.properties[i].enable();\n    this.enabled = true;\n  },\n\n  /**\n   * Disable strict mode.\n   *\n   * @public\n   */\n  disable: function() {\n    if (!this.enabled) return;\n    debug('disable');\n    var i = this.properties.length;\n    while (i--) this.properties[i].disable();\n    this.enabled = false;\n    this.phase(null);\n  },\n\n  /**\n   * Create wrappers for each of\n   * of the prototype properties.\n   *\n   * @private\n   */\n  createPrototypeProperties: function() {\n    debug('create prototype properties');\n    var props = properties.prototype;\n    for (var key in props) {\n      for (var name in props[key]) {\n        var object = this.win[key] && this.win[key].prototype;\n        if (!object || !object.hasOwnProperty(name)) continue;\n        this.properties.push(this.create(object, name, props[key][name]));\n      }\n    }\n  },\n\n  /**\n   * Create wrappers for each of\n   * of the instance properties.\n   *\n   * @private\n   */\n  createInstanceProperties: function() {\n    debug('create instance properties');\n    var props = properties.instance;\n    for (var key in props) {\n      for (var name in props[key]) {\n        var object = this.win[key];\n        if (!object || !object.hasOwnProperty(name)) continue;\n        this.properties.push(this.create(object, name, props[key][name]));\n      }\n    }\n  },\n\n  /**\n   * Create a wrapped `Property` that\n   * can be individually enabled/disabled.\n   *\n   * @param  {Object} object - the parent object (eg. Node.prototype)\n   * @param  {String} name - the property name (eg. 'appendChild')\n   * @param  {(constructor|Object)} config - from the above property definition\n   * @return {Property}\n   */\n  create: function(object, name, config) {\n    debug('create', name);\n    var Constructor = config.type || config;\n    return new Constructor(object, name, config, this);\n  }\n};\n\n/**\n * Create a new `Property`.\n *\n * A wrapper around a property that observes\n * usage, throwing errors when used in the\n * incorrect phase.\n *\n * @param {Object} object - the parent object (eg. Node.prototype)\n * @param {[type]} name - the property name (eg. 'appendChild')\n * @param {(constructor|Object)} config - from the above definition\n * @param {StrictDom} strictdom - injected as a dependency\n */\nfunction Property(object, name, config, strictdom) {\n  debug('Property', name, config);\n\n  this.strictdom = strictdom;\n  this.object = object;\n  this.name = name;\n\n  var descriptor = this.getDescriptor();\n\n  // defaults can be overriden from config\n  if (typeof config == 'object') Object.assign(this, config);\n\n  this.descriptors = {\n    unwrapped: descriptor,\n    wrapped: this.wrap(descriptor)\n  };\n}\n\nProperty.prototype = {\n\n  /**\n   * Get the property's descriptor.\n   *\n   * @return {Object}\n   * @private\n   */\n  getDescriptor: function() {\n    debug('get descriptor', this.name);\n    return Object.getOwnPropertyDescriptor(this.object, this.name);\n  },\n\n  /**\n   * Enable observation by replacing the\n   * current descriptor with the wrapped one.\n   *\n   * @private\n   */\n  enable: function() {\n    debug('enable', this.name);\n    Object.defineProperty(this.object, this.name, this.descriptors.wrapped);\n  },\n\n  /**\n   * Disable observation by replacing the\n   * current descriptor with the original one.\n   *\n   * @private\n   */\n  disable: function() {\n    debug('disable', this.name);\n    Object.defineProperty(this.object, this.name, this.descriptors.unwrapped);\n  },\n\n  // to be overwritten by subclass\n  wrap: function() {}\n};\n\n/**\n * A wrapper for properties that measure\n * geometry data from the DOM.\n *\n * Once a `Measure` property is enabled\n * it can only be used when StrictDom\n * is in the 'measure' phase, else it\n * will throw.\n *\n * @constructor\n * @extends Property\n */\nfunction Measure() {\n  Property.apply(this, arguments);\n}\n\nMeasure.prototype = extend(Property, {\n\n  /**\n   * Return a wrapped descriptor.\n   *\n   * @param  {Object} descriptor\n   * @return {Object}\n   */\n  wrap: function(descriptor) {\n    debug('wrap measure', this.name);\n\n    var clone = Object.assign({}, descriptor);\n    var value = descriptor.value;\n    var get = descriptor.get;\n    var self = this;\n\n    if (typeof value == 'function') {\n      clone.value = function() {\n        debug('measure', self.name);\n        self.test(self.strictdom, this, arguments);\n        return value.apply(this, arguments);\n      };\n    } else if (get) {\n      clone.get = function() {\n        debug('measure', self.name);\n        self.test(self.strictdom, this, arguments);\n        return get.apply(this, arguments);\n      };\n    }\n\n    return clone;\n  },\n\n  /**\n   * Throws an Error if the element is attached\n   * and StrictDOM is not in the 'measure' phase.\n   *\n   * If methods/properties are used without\n   * a context (eg. `getComputedStyle()` instead\n   * of `window.getComputedStyle()`) we infer\n   * a `window` context.\n   *\n   * @param  {StrictDom} strictdom\n   * @param  {Node} ctx\n   */\n  test: function(strictdom, ctx) {\n    if (isAttached(ctx || window) && strictdom.not('measure')) {\n      throw error(2, this.name);\n    }\n  }\n});\n\n/**\n * A wrapper for properties that mutate\n * to the DOM, triggering style/reflow\n * operations.\n *\n * Once a `Mutate` property is enabled\n * it can only be used when StrictDom\n * is in the 'measure' phase, else it\n * will throw.\n *\n * @constructor\n * @extends Property\n */\nfunction Mutate() {\n  Property.apply(this, arguments);\n}\n\nMutate.prototype = extend(Property, {\n\n  /**\n   * Return a wrapped descriptor.\n   *\n   * @param  {Object} descriptor\n   * @return {Object}\n   */\n  wrap: function(descriptor) {\n    debug('wrap mutate', this.name);\n\n    var clone = Object.assign({}, descriptor);\n    var value = descriptor.value;\n    var self = this;\n\n    if (typeof value == 'function') {\n      clone.value = function() {\n        self.test(self.strictdom, this, arguments);\n        return value.apply(this, arguments);\n      };\n    } else if (descriptor.set) {\n      clone.set = function() {\n        self.test(self.strictdom, this, arguments);\n        return descriptor.set.apply(this, arguments);\n      };\n    }\n\n    return clone;\n  },\n\n  /**\n   * Throws an Error if the element is attached\n   * and StrictDOM is not in the 'mutate' phase.\n   *\n   * If methods/properties are used without\n   * a context (eg. `getComputedStyle()` instead\n   * of `window.getComputedStyle()`) we infer\n   * a `window` context.\n   *\n   * @param  {StrictDom} strictdom\n   * @param  {Node} ctx\n   */\n  test: function(strictdom, ctx) {\n    if (isAttached(ctx || window) && strictdom.not('mutate')) {\n      throw error(3, this.name);\n    }\n  }\n});\n\n/**\n * A wrapper for 'accessor' (get/set) properties.\n *\n * An `Accessor` should be used to wrap\n * properties that can both measure and mutate\n * the DOM (eg. `element.scrollTop`).\n *\n * @constructor\n * @extends Property\n */\nfunction Accessor() {\n  Property.apply(this, arguments);\n}\n\nAccessor.prototype = extend(Property, {\n\n  /**\n   * Return a wrapped descriptor.\n   *\n   * @param  {Object} descriptor\n   * @return {Object}\n   */\n  wrap: function(descriptor) {\n    debug('wrap accessor', this.name);\n\n    var clone = Object.assign({}, descriptor);\n    var get = descriptor.get;\n    var set = descriptor.set;\n    var self = this;\n\n    if (get) {\n      clone.get = function() {\n        self.testRead(self.strictdom, this, arguments);\n        return get.apply(this, arguments);\n      };\n    }\n\n    if (descriptor.set) {\n      clone.set = function() {\n        self.testWrite(self.strictdom, this, arguments);\n        return set.apply(this, arguments);\n      };\n    }\n\n    return clone;\n  },\n\n  testRead: Measure.prototype.test,\n  testWrite: Mutate.prototype.test\n});\n\n/**\n * A wrapper for 'value' properties.\n *\n * A `Value` should be used to wrap special\n * values that like `window.innerWidth`, which\n * in Chrome (not Gecko) are not normal 'getter'\n * functions, but magical flat getters.\n *\n * Value wrappers are a for very special cases.\n *\n * @constructor\n * @extends Property\n */\nfunction Value() {\n  Property.apply(this, arguments);\n}\n\nValue.prototype = extend(Property, {\n\n  /**\n   * Calling `Object.getOwnDescriptor()` can\n   * trigger a reflow as it returns the `value`\n   * of the property. So here we just\n   * return an empty object instead.\n   *\n   * @return {Object}\n   * @private\n   */\n  getDescriptor: function() {\n    return {};\n  },\n\n  /**\n   * Value wrappers are disabled by simply\n   * deleting them from the instance,\n   * revealing the original descriptor.\n   *\n   * @private\n   */\n  disable: function() {\n    delete this.object[this.name];\n  },\n\n  /**\n   * Return a wrapped descriptor.\n   *\n   * `Value` properties are actually on the\n   * instance of objects. To wrap them we need\n   * to replace them with a getter which\n   * deletes itself on access, call into the v8\n   * interceptor, and then add themselves back.\n   *\n   * This won't be fast, but these are rarely\n   * accessed so it should be fine.\n   *\n   * @param  {Object} descriptor\n   * @return {Object}\n   */\n  wrap: function(descriptor) {\n    debug('wrap value');\n    var name = this.name;\n    var self = this;\n\n    descriptor.get = function() {\n      debug('get value', name);\n      self.test(self.strictdom, this, arguments);\n      self.disable();\n      var result = this[name];\n      self.enable();\n      return result;\n    };\n\n    return descriptor;\n  },\n\n  test: Measure.prototype.test\n});\n\nfunction Style() {\n  Property.apply(this, arguments);\n}\n\nStyle.prototype = extend(Property, {\n  wrap: function(descriptor) {\n    debug('wrap style');\n    var strictdom = this.strictdom;\n    var clone = Object.assign({}, descriptor);\n    clone.get = function() { return new StrictStyle(this, strictdom); };\n    return clone;\n  }\n});\n\nfunction ClassList() {\n  Property.apply(this, arguments);\n}\n\nClassList.prototype = extend(Property, {\n  wrap: function(descriptor) {\n    debug('wrap style');\n    var strictdom = this.strictdom;\n    var clone = Object.assign({}, descriptor);\n    clone.get = function() { return new StrictClassList(this, strictdom); };\n    return clone;\n  }\n});\n\nfunction StrictStyle(el, strictdom) {\n  this.strictdom = strictdom;\n  this.el = el;\n}\n\nStrictStyle.prototype = {\n  _getter: getDescriptor(HTMLElement.prototype, 'style').get,\n  _get: function() {\n    return this._getter.call(this.el);\n  },\n\n  setProperty: function(key, value) {\n    var illegal = isAttached(this.el) && this.strictdom.not('mutate');\n    if (illegal) throw error(1, 'style.' + key);\n    return this._get()[key] = value;\n  },\n\n  removeProperty: function(key) {\n    var illegal = isAttached(this.el) && this.strictdom.not('mutate');\n    if (illegal) throw error(1, 'style.' + key);\n    return this._get().removeProperty(key);\n  }\n};\n\n// dynamically construct prototype\n// from real element.style\n(function() {\n  var styles = document.createElement('div').style;\n  var proto = {};\n\n  for (var key in styles) {\n    if (styles[key] === '') {\n      Object.defineProperty(StrictStyle.prototype, key, {\n        get: getter(key),\n        set: setter(key)\n      });\n    }\n  }\n\n  [\n    'item',\n    'getPropertyValue',\n    'getPropertyCSSValue',\n    'getPropertyPriority'\n  ].forEach(function(method) {\n    StrictStyle.prototype[method] = caller(method);\n  });\n\n  function getter(key) {\n    return function() {\n      return this._get()[key];\n    };\n  }\n\n  function setter(key) {\n    return function(value) {\n      var illegal = isAttached(this.el) && this.strictdom.not('mutate');\n      if (illegal) throw error(1, 'style.' + key);\n      return this.setProperty(key, value);\n    };\n  }\n\n  function caller(key) {\n    return function() {\n      var style = this._get();\n      return style[key].apply(style, arguments);\n    };\n  }\n\n  return proto;\n})();\n\nfunction StrictClassList(el, strictdom) {\n  this.strictdom = strictdom;\n  this.el = el;\n}\n\nStrictClassList.prototype = {\n  _getter: getDescriptor(Element.prototype, 'classList').get,\n  _get: function() { return this._getter.call(this.el); },\n\n  add: function(className) {\n    var illegal = isAttached(this.el) && this.strictdom.not('mutate');\n    if (illegal) throw error(1, 'class names');\n    this._get().add(className);\n  },\n\n  contains: function(className) {\n    return this._get().contains(className);\n  },\n\n  remove: function(className) {\n    var illegal = isAttached(this.el) && this.strictdom.not('mutate');\n    if (illegal) throw error(1, 'class names');\n    this._get().remove(className);\n  },\n\n  toggle: function() {\n    var illegal = isAttached(this.el) && this.strictdom.not('mutate');\n    if (illegal) throw error(1, 'class names');\n    var classList = this._get();\n    return classList.toggle.apply(classList, arguments);\n  }\n};\n\n/**\n * Utils\n */\n\nfunction error(type) {\n  return new Error({\n    1: 'Can only set ' + arguments[1] + ' during \\'mutate\\' phase',\n    2: 'Can only get ' + arguments[1] + ' during \\'measure\\' phase',\n    3: 'Can only call `.' + arguments[1] + '()` during \\'mutate\\' phase',\n    4: 'Invalid phase: ' + arguments[1]\n  }[type]);\n}\n\nfunction getDescriptor(object, prop) {\n  return Object.getOwnPropertyDescriptor(object, prop);\n}\n\nfunction extend(parent, props) {\n  return Object.assign(Object.create(parent.prototype), props);\n}\n\nfunction isAttached(el) {\n  return el === window || document.contains(el);\n}\n\n/**\n * Exports\n */\n\n// Only ever allow one `StrictDom` per document\nvar exports = window['strictdom'] = (window['strictdom'] || new StrictDom(window)); // jshint ignore:line\n\n// CJS & AMD support\nif ((typeof define)[0] == 'f') define(function() { return exports; });\nelse if ((typeof module)[0] == 'o') module.exports = exports;\n\n})();\n"],"sourceRoot":""}